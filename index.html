<html>
	<head>
		<meta charset="UTF-8"> 
		<style>
		html, body {
            width: 100%;
            height: 100%
			background: #BB8;
            margin: 0;
		}
        canvas {
            width: 100%;
            height: 100%;
            background-color: #EEE;
        }
		</style>
	</head>
	<body>
        <canvas></canvas>
		<script>
"use strict";

var canvas = document.getElementsByTagName('canvas')[0]
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
var context = canvas.getContext('2d');

function Cell(correct, active, primarySelection, secondarySelection, secondaryActive) {
    return {
        correct: correct,
        active: active,
        primarySelection: primarySelection,
        secondarySelection: secondarySelection,
        secondaryActive: secondaryActive,
    }
}

var m, a, m2;
var board;
function buildBoard(newM) {
    m = newM;
    m2 = 2 * m - 2;
    board = [];
    for (var i = 0; i <= m2; i++) {
        var line = [];
        board.push(line);
        for (var j = 0; j <= m2; j++) {
            line.push(Cell(false, false, false, false, false));
        }
    }
}

var cellSpace = 30;
var cellPadding = 1;
var cellBorder = 4;
var cellSize = cellSpace - cellPadding * 2;
var topPadding = 50;
function cellY(row) { return topPadding + row * cellSpace + cellPadding; }
function cellX(col) { return (canvas.width/2 - (m2/2-col)*cellSpace + cellPadding)|0; }
function rowY(y) { return Math.round((y - topPadding) / cellSpace - 0.5); }
function colX(x) { return Math.round((x - canvas.width/2) / cellSpace + m2/2 - 0.5); }

function render() {
    context.clearRect(0, 0, canvas.width, canvas.height);

    context.save();
    context.font = '16px Verdana';
    for (var i = 0; i < m; i++) {

    }
    context.restore();

    context.save();
    for (var i = 0; i <= m2; i++) {
        for (var j = 0; j <= m2; j++) {
            var cell = board[i][j];
            context.fillStyle = cell.correct ? '#8B8' : '#B88';
            context.globalAlpha = cell.active ? 1 : 0.3;
            context.fillRect(cellX(j), cellY(i),
                             cellSize, cellSize);
            context.fillStyle = '#333';
            context.fillRect(cellX(j)+cellBorder, cellY(i)+cellBorder,
                             cellSize-cellBorder*2, cellSize-cellBorder*2);

            if (cell.primarySelection) {
                context.fillStyle = '#FFF';
                context.beginPath();
                context.moveTo(cellX(j)+cellBorder, cellY(i)+cellBorder);
                context.lineTo(cellX(j)+cellSize-cellBorder, cellY(i)+cellBorder);
                context.lineTo(cellX(j)+cellBorder, cellY(i)+cellSize-cellBorder);
                context.fill();
            }

            if (cell.secondarySelection) {
                context.fillStyle = '#FFF';
                context.globalAlpha = cell.secondaryActive ? 1 : 0.3;
                context.beginPath();
                context.moveTo(cellX(j)+cellSize-cellBorder, cellY(i)+cellSize-cellBorder);
                context.lineTo(cellX(j)+cellSize-cellBorder, cellY(i)+cellBorder);
                context.lineTo(cellX(j)+cellBorder, cellY(i)+cellSize-cellBorder);
                context.fill();
            }
        }
    }
    context.restore();
}

function buildAnswer() {
    for (var row = 0; row <= m2; row++) {
        for (var col = 0; col <= m2; col++) {
            var xored0 = row - m >= col && (row - col - m) % (m - a) == 0;
            var xoredA = col >= a && (a + row - col - m) % (m - a) == 0;
            var isCorrect = row >= col && (row == col || (row >= m && xoredA ^ xored0));
            board[row][col].correct = isCorrect;
            board[row][col].active = row == col;
        }
    }
}

buildBoard(10);
a = 1;
buildAnswer();

var selecting = false;
var selectionStart = -1;
var selectionEnd = -1;
var secondarySelectionStart = -1;

function updateSelectionStatus() {
    var selectionType;

    var start, end;
    if (selecting) {
        selectionType = 'primary';
        start = Math.min(selectionStart, selectionEnd);
        end = Math.max(selectionStart, selectionEnd);
    } else if (selectionStart !== -1) {
        selectionType = 'secondary';
        start = secondarySelectionStart;
        end = start + Math.abs(selectionStart - selectionEnd);
    } else {
        selectionType = 'none';
    }

    for (var row = 0; row <= m2; row++) {
        for (var col = 0; col <= m2; col++) {
            var inRange = col >= start && col <= end;
            if (selectionType == 'primary') {
                board[row][col].primarySelection = inRange;
            } else if (selectionType == 'secondary') {
                board[row][col].secondarySelection = inRange;
                var distance = col - start;
                var src = Math.min(selectionStart, selectionEnd) + distance;
                board[row][col].secondaryActive = (src >= 0 && src <= m2) && board[row][src].active;
            } else {
                board[row][col].primarySelection = false;
                board[row][col].secondarySelection = false;
            }
        }
    }
}
canvas.onmousedown = function(e) {
    var col = colX(e.clientX);
    if (selectionStart === -1) {
        selecting = true;
        selectionStart = col;
        selectionEnd = col;
    } else {
        updateSelectionStatus();
        for (var i = 0; i <= Math.abs(selectionEnd - selectionStart); i++) {
            var col = secondarySelectionStart + i;
            if (col < 0 || col > m2) {
                continue;
            }
            for (var row = 0; row <= m2; row++) {
                board[row][col].active ^= board[row][col].secondaryActive;
            }
        }
        selecting = false;
        selectionStart = -1;
        selectionEnd = -1;
    }
    updateSelectionStatus();
}
canvas.onmouseup = function(e) {
    selecting = false;
    selectionEnd = colX(e.clientX);
    secondarySelectionStart = colX(e.clientX);
    updateSelectionStatus();
}
canvas.onmousemove = function(e) {
    if (selecting) {
        selectionEnd = colX(e.clientX);
        updateSelectionStatus();
    } else if (selectionStart !== -1) {
        secondarySelectionStart = colX(e.clientX);
        updateSelectionStatus();
    }
}
//setInterval(function() { a = (a + 1) % m; buildAnswer(); render(); }, 1000);

function update() { render(); window.requestAnimationFrame(update); }
update();
		</script>
	</body>
</html>
