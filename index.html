<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width" />
        <title>Binary Polynomial Reduction - A Game for One</title>
        <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            width: 100%;
            height: 100%;
            background-color: #456990;
        }
        </style>
    </head>
    <body>
        <canvas></canvas>
        <script>
"use strict";

var canvas = document.getElementsByTagName('canvas')[0]
var context = canvas.getContext('2d');

function Cell(active, primarySelection, secondarySelection, secondaryActive) {
    return {
        active: active,
        primarySelection: primarySelection,
        secondarySelection: secondarySelection,
        secondaryActive: secondaryActive,
    }
}

var m, a, m2;
var board;
function buildBoard() {
    m = Math.max(2, Math.min(100, m));
    a = Math.max(1, Math.min(m-1, a));
    m2 = 2 * m - 2;
    board = [];
    for (var i = 0; i <= m2; i++) {
        var line = [];
        board.push(line);
        for (var j = 0; j <= m2; j++) {
            line.push(Cell(i == j, false, false, false, false));
        }
    }

    updateDimensions();
}

var cellSpace, cellPadding, cellBorder, cellSize, canvasPadding;
function updateDimensions() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    canvasPadding = canvas.height / 20;
    cellSpace = ((Math.min(canvas.width, canvas.height) - 2 * canvasPadding) / (m2+1))|0;
    cellPadding = Math.max(1, (cellSpace / 20)|0);
    cellBorder = (cellSpace / 5)|0;
    cellSize = cellSpace - cellPadding * 2;

    render();
}

window.onresize = updateDimensions;
function cellY(row) { return canvasPadding + row * cellSpace; }
function cellX(col) { return (canvas.width/2 + (col-(m2+1)/2)*cellSpace)|0; }
function rowY(y) { return Math.round((y - canvasPadding) / cellSpace - 0.5); }
function colX(x) { return Math.round((x - canvas.width/2) / cellSpace + (m2+1)/2 - 0.5); }
function isCorrect(row, col) {
    var xored0 = row - m >= col && (row - col - m) % (m - a) == 0;
    var xoredA = col >= a && (a + row - col - m) % (m - a) == 0;
    return row >= col && (row == col || (row >= m && xoredA ^ xored0));
}

function drawCell(row, col) {
    var correct = isCorrect(row, col);
    var cell = board[row][col];
    if (!correct && !cell.active) {
        return;
    }

    if (correct) {
        context.fillStyle = cell.active ? '#33DD33' : '#459990';
    } else if (cell.active) {
        context.fillStyle = '#CC3333';
    }
    context.fillRect(cellX(col) + cellPadding, cellY(row),
                     cellSize, cellSize);
    if (cellSpace > 10) {
        context.strokeStyle = '#CCC';
        context.strokeRect(cellX(col) + cellPadding, cellY(row),
                           cellSize, cellSize);
    }
}

function render() {
    context.clearRect(0, 0, canvas.width, canvas.height);

    context.save();
    context.fillStyle = '#CCC';
    context.font = '16px Verdana';
    context.textAlign = 'right';
    context.fillText("m="+m, canvas.width - 10, canvas.height - 30);
    context.fillText("a="+a, canvas.width - 10, canvas.height - 10);
    context.restore();

    context.save();
    for (var i = 0; i <= m2; i++) {
        for (var j = 0; j <= m2; j++) {
            context.globalAlpha = 1;
            drawCell(i, j);

            var cell = board[i][j];
            if (cell.primarySelection) {
                context.fillStyle = '#EEE';
                context.globalAlpha = cell.active ? 1 : 0.2;
                context.beginPath();
                context.moveTo(cellX(j)+cellBorder, cellY(i)+cellBorder);
                context.lineTo(cellX(j)+cellSize-cellBorder, cellY(i)+cellBorder);
                context.lineTo(cellX(j)+cellBorder, cellY(i)+cellSize-cellBorder);
                context.fill();
            }

            if (cell.secondarySelection) {
                context.fillStyle = '#EEE';
                context.globalAlpha = cell.secondaryActive ? 0.9 : 0.1;
                context.beginPath();
                context.moveTo(cellX(j)+cellSize-cellBorder, cellY(i)+cellSize-cellBorder);
                context.lineTo(cellX(j)+cellSize-cellBorder, cellY(i)+cellBorder);
                context.lineTo(cellX(j)+cellBorder, cellY(i)+cellSize-cellBorder);
                context.fill();
            }
        }
    }
    context.restore();
}

var urlParam = window.location.hash.slice(1);
if (urlParam) {
    m = urlParam.split(',')[0];
    a = urlParam.split(',')[1];
} else {
    m = 3;
    a = 1;
}
buildBoard();

var selecting = false;
var selectionStart = -1;
var selectionEnd = -1;
var secondarySelectionStart = -1;

function testVictory() {
    for (var row = 0; row <= m2; row++) {
        for (var col = 0; col <= m2; col++) {
            var cell = board[row][col];
            if (cell.active != isCorrect(row, col)) {
                return;
            }
        }
    }
    m += 1;
    a = (Math.random()*(m-1) + 1)|0;
    buildBoard();
}

function updateSelectionStatus() {
    var selectionType;

    var start, end;
    if (selecting) {
        selectionType = 'primary';
        start = Math.min(selectionStart, selectionEnd);
        end = Math.max(selectionStart, selectionEnd);
    } else if (selectionStart !== -1) {
        selectionType = 'secondary';
        start = secondarySelectionStart;
        end = start + Math.abs(selectionStart - selectionEnd);
    } else {
        selectionType = 'none';
    }

    for (var row = 0; row <= m2; row++) {
        for (var col = 0; col <= m2; col++) {
            var inRange = col >= start && col <= end;
            if (selectionType == 'primary') {
                board[row][col].primarySelection = inRange;
            } else if (selectionType == 'secondary') {
                board[row][col].secondarySelection = inRange;
                var distance = col - start;
                var src = Math.min(selectionStart, selectionEnd) + distance;
                board[row][col].secondaryActive = (src >= 0 && src <= m2) && board[row][src].active;
            } else {
                board[row][col].primarySelection = false;
                board[row][col].secondarySelection = false;
            }
        }
    }
}
canvas.onmousedown = function(e) {
    if (e.which === 3) {
        return;
    }
     
    var col = colX(e.clientX);
    if (selectionStart === -1) {
        selecting = true;
        selectionStart = col;
        selectionEnd = col;
    } else if (selectionStart != col && selectionEnd != col) {
        updateSelectionStatus();
        for (var i = 0; i <= Math.abs(selectionEnd - selectionStart); i++) {
            var col = secondarySelectionStart + i;
            if (col < 0 || col > m2) {
                continue;
            }
            for (var row = 0; row <= m2; row++) {
                board[row][col].active ^= board[row][col].secondaryActive;
            }
        }
        selecting = false;
        if (!e.shiftKey) {
            selectionStart = -1;
            selectionEnd = -1;
        }
    }
    updateSelectionStatus();
    setTimeout(testVictory, 1000)
};
canvas.onmouseup = function(e) {
    if (selecting) {
        selecting = false;
        selectionEnd = colX(e.clientX);
        secondarySelectionStart = colX(e.clientX);
        updateSelectionStatus();
    }
};
canvas.onmousemove = function(e) {
    if (selecting) {
        selectionEnd = colX(e.clientX);
        updateSelectionStatus();
    } else if (selectionStart !== -1) {
        secondarySelectionStart = colX(e.clientX);
        updateSelectionStatus();
    }
};
canvas.onwheel = function(e) {
    if (e.shiftKey) {
        m = Math.max(2, Math.min(100, m + (e.deltaY < 0 ? 1 : -1)));
        a = Math.max(1, Math.min(m - 1, a));
        buildBoard();
        updateDimensions();
    } else {
        a = Math.max(1, Math.min(m - 1, a + (e.deltaY < 0 ? 1 : -1)));
        updateDimensions();
    }
    return false;
};
canvas.oncontextmenu = function(e) {
    selecting = false;
    selectionStart = -1;
    selectionEnd = -1;
    updateSelectionStatus();
    return false;
};
//setInterval(function() { a = (a + 1) % m; buildAnswer(); render(); }, 1000);

function update() { render(); window.requestAnimationFrame(update); }
update();
        </script>
    </body>
</html>
